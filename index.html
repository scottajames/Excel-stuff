<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>PSOP Connect - Excel Transformer with Preview</title>
<script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
<style>
body{font-family:Calibri, sans-serif;background:#f5f5f5;margin:0;padding:20px;color:#222}
.container{max-width:1200px;margin:0 auto}
h1{font-size:22px;margin-bottom:20px}
.upload-area{border:2px dashed #217346;padding:40px;text-align:center;background:white;border-radius:6px;color:#217346;cursor:pointer;font-weight:bold;margin-bottom:20px}
.upload-area:hover{background:#e6f2e6}
button{padding:10px 14px;border:none;border-radius:4px;background:#217346;color:#fff;cursor:pointer;font-size:16px;margin-bottom:20px;display:none;}
button:hover{background:#1a5a2f}
table{border-collapse:collapse;margin-top:20px;width:100%;font-family:Calibri,sans-serif;font-size:14px;table-layout:fixed}
th,td{border:1px solid #999;padding:6px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;text-align:left}
th{background:#217346;color:#fff;font-weight:bold;text-align:center}
.preview-section{margin-top:30px}
</style>
</head>
<body>
<div class="container">
  <h1>MBS - DUT & Security Mapping tool</h1>

  <h3>Known errors and how to fix them.</h3>
  <p><b>Nothing happens when I drag and drop my file:</b> sometimes when you drag and drop it does not work. The best thing to do is reload the page and instead of drag and dropping click on the "Drag &amp; Drop or Click to Upload Excel file" and select the file from your folders instead.</p>
  <p><b>It has put the incorrect security mapping:</b> you are still required to look and audit the mappings yourself which is why a preview of what you're going to download is shown. If someone has filled in the sheet wrong in MBS, this tool cannot edit the data; it only shows and formats the data the Excel file has.</p>
  <p><b>It is missing parts or all of the mapping:</b> this tool cannot edit mapping—only format it from the file that is downloaded from MBS. The issue probably isn't the tool but the person who filled in the MBS file.</p>
<h3 style=color:red;>This is just a tool for mapping; it does not give authority for security roles.</h3>
<div id="uploadArea" class="upload-area">
Drag & Drop or Click to Upload MBS Excel file
<input type="file" id="fileInput" accept=".xlsx" style="display:none" />
</div>

<button id="processBtn">Process & Download Excel</button>

<div id="previewContainer" class="preview-section"></div>

<script>
document.addEventListener("DOMContentLoaded", () => {

    const uploadArea = document.getElementById("uploadArea");
    const fileInput = document.getElementById("fileInput");
    const previewContainer = document.getElementById("previewContainer");
    const processBtn = document.getElementById("processBtn");
    let uploadedFile = null;
    let uploadedRows = [];
    
    // Store valid units from Unit.csv
    let validUnits = new Set();
    
    // Fixed file path to Unit.csv (adjust this path as needed)
    const UNIT_CSV_PATH = "S:\FP\DOI\117_PROGRAMME_MGT\101_PROGRAMMES\Total_Technology\Core_Policing\New Core Policing Programme\MiPS\BA Work\Roles\HR Interface and Security Roles\Secure Data Sources\2024 Access Tracker\Unit.csv"; // Update this to the actual path if different
    
    // Load Unit.csv on page load
    function loadUnitCSV() {
        fetch(UNIT_CSV_PATH)
            .then(response => {
                if (!response.ok) {
                    console.warn("Unit.csv not found or cannot be loaded. Work tray validation will be skipped.");
                    return null;
                }
                return response.text();
            })
            .then(data => {
                if (data) {
                    // Parse CSV data (simple parsing)
                    const lines = data.split('\n');
                    lines.forEach(line => {
                        if (line.trim()) {
                            // Get first column (column A)
                            const columns = line.split(',');
                            if (columns.length > 0) {
                                const unit = columns[0].trim().toUpperCase();
                                if (unit) {
                                    validUnits.add(unit);
                                }
                            }
                        }
                    });
                    console.log(`Loaded ${validUnits.size} valid units from Unit.csv`);
                }
            })
            .catch(error => {
                console.warn("Error loading Unit.csv:", error);
                console.warn("Work tray validation will be skipped.");
            });
    }
    
    // Load Unit.csv when page loads
    loadUnitCSV();

    // VALID SECURITY ROLES LIST
    // These are the valid security roles for column V
    const VALID_SECURITY_ROLES = [
	"BOLT_ON_1",
	"BOLT_ON_2",
	"BOLT_ON_3",
	"BOLT_ON_4",
	"BOLT_ON_5",
	"BOLT_ON_6",
	"BOLT_ON_7",
	"BOLT_ON_8",
	"CONSTABLE",
	"SGT",
	"INSP",
	"C_INSP",
	"SUPT",
	"C_SUPT",
	"COMMDR",
	"DEP_ASS_COMMIS",
	"SUPT",
	"ASS_COMMIS",
	"DEP_COMMIS",
	"COMMIS",
	"MSC_CONS",
	"MSC_SGT",
	"MSC_INSP",
	"MSC_CINSP",
	"MSC_ASS_CO",
	"MSC_CO",
	"SGT_CUST",
	"HCP",
	"HCP_FTAC",
	"CCC",
	"DDO",
	"PAO",
	"PCSO",
	"INVESTIGATOR",
	"SUP_INVESTIGATOR",
	"ANPR",
	"FCR",
	"FORENSICS",
	"INTEL",
	"INTEL_MANAGER",
	"INTEL_SIU",
	"INTEL_SOURCE",
	"INTEL_ENQUIRY_LOG",
	"PNCB",
	"PROPERTY",
	"PSD",
	"TDIU",
	"CMS",
	"DDM",
	"CMT",
	"CPA",
	"CASE_TRAFFIC",
	"CJOMS",
	"MET_INTERNAL",
	"VIEW_AND_SEARCH",
	"VIEW_ONLY",
	"MI",
	"MOPI",
	"FLAGS_C2S",
	"FLAGS_NDH",
	"FLAGS_NT",
	"FLAGS_VIEW_USERS",
	"SEALED_AUDIT",
	"NO_FIELD_SEC",
	"COVERT_ACCESS_FLAG",
	"FLAG_CLOSED_ACCESS",
	"FLAG_SECURE_ACCESS",
	"FLAG_TEAM",
	"SW_ALL_ACCESS",
	"PMP_ALL_ACCESS",
	"PMP_USER",
	"SYS_ADMIN",
	"SYSADMIN_FULL",
	"SYSADMIN_DQ1",
	"SYSADMIN_DQ2",
	"SYS_ADMIN_DQFULL",
	"FULL_SYS_ADMIN",
	"SYSADMIN_CST",
	"SYSADMIN_CST_FULL",
	"LOCKED_ADMIN",
	"SYSADMIN_NEC"
    ];
    
    // Create a normalized version of valid roles for comparison
    const NORMALIZED_VALID_ROLES = VALID_SECURITY_ROLES.map(role => 
        normalizeSecurityRole(role)
    );
    
    // Helper function to normalize security roles for comparison
    function normalizeSecurityRole(role) {
        if (!role) return "";
        return role.toString()
            .trim()
            .toLowerCase()
            .replace(/_/g, ' ')      // Convert underscores to spaces
            .replace(/\s+/g, ' ')    // Normalize multiple spaces to single space
            .trim();
    }
    
    // Helper function to find matching valid role from input
    function findMatchingValidRole(inputRole) {
        if (!inputRole) return null;
        
        const normalizedInput = normalizeSecurityRole(inputRole);
        
        // Try to find exact match in normalized list
        const exactMatchIndex = NORMALIZED_VALID_ROLES.indexOf(normalizedInput);
        if (exactMatchIndex !== -1) {
            return VALID_SECURITY_ROLES[exactMatchIndex]; // Return original format
        }
        
        return null; // No match found
    }

    // Upload handlers
    uploadArea.addEventListener("click", () => fileInput.click());
    uploadArea.addEventListener("dragover", e => { e.preventDefault(); uploadArea.style.background="#e6f2e6"; });
    uploadArea.addEventListener("dragleave", () => { uploadArea.style.background="white"; });
    uploadArea.addEventListener("drop", e => { 
        e.preventDefault(); 
        uploadArea.style.background="white"; 
        if(e.dataTransfer.files && e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); 
    });
    fileInput.addEventListener("change", e => handleFile(e.target.files[0]));

    function handleFile(file) {
        uploadedFile = file;
        uploadArea.textContent = `File Loaded: ${file.name}`;
        const reader = new FileReader();
        reader.onload = e => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            uploadedRows = XLSX.utils.sheet_to_json(sheet, { defval:"" });
            renderPreview(uploadedRows);
            processBtn.style.display = "inline-block"; // show download button
        };
        reader.readAsArrayBuffer(uploadedFile);
    }

    function getHighestNonEmptyLevel(row) {
        const levels = ["Level 8 Sub-Team","Level 7 Team","Level 6 Function","Level 5 Portfolio","Level 4 Organisation"];
        for (let lvl of levels) {
            if (row[lvl] && row[lvl].toString().trim() !== "") return row[lvl].toString().trim();
        }
        return "";
    }

    function getDUTAccessColumnValue(row) {
        // Try to find column S by index or by common names
        const columnNames = Object.keys(row);
        
        // Look for common DUT access column names - column S
        const dutColumnCandidates = [
            "Connect DUT?", 
            "DUT Access", 
            "Access to DUT",
            "Access To Connect",
            "Column S",  // Fallback
            columnNames[18] // Assuming S is 19th column (0-indexed 18)
        ];
        
        for (const colName of dutColumnCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim().toLowerCase();
            }
        }
        
        return "";
    }

    function getWorkTrayNameValue(row) {
        // Try to find column U (Work Tray Name)
        const columnNames = Object.keys(row);
        
        // Look for Work Tray Name column - column U
        const workTrayCandidates = [
            "Work Tray Name",
            "Column U",  // Fallback
            columnNames[20] // Assuming U is 21st column (0-indexed 20)
        ];
        
        for (const colName of workTrayCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim();
            }
        }
        
        return "";
    }

    function getSecurityRoleValue(row) {
        // Try to find column V (Connect Security Role)
        const columnNames = Object.keys(row);
        
        // Look for Security Role column - column V
        const securityCandidates = [
            "Connect Security Role",
            "Column V",  // Fallback
            columnNames[21] // Assuming V is 22nd column (0-indexed 21)
        ];
        
        for (const colName of securityCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim();
            }
        }
        
        return "";
    }

    function validateAndFormatSecurityRole(role) {
        if (!role) return { isValid: false, formattedRole: "", message: "", matchedRole: null };
        
        const matchedValidRole = findMatchingValidRole(role);
        
        if (!matchedValidRole) {
            return { 
                isValid: false, 
                formattedRole: "INVALID SECURITY ROLE", 
                message: "Not a valid security role", 
                matchedRole: null 
            };
        }
        
        // Return the role in the standard format (uppercase with underscores)
        const formattedRole = matchedValidRole;
        
        return { 
            isValid: true, 
            formattedRole: formattedRole, 
            message: formattedRole,
            matchedRole: matchedValidRole
        };
    }

    function determineWorkTrayName(row) {
        const dutAccess = getDUTAccessColumnValue(row);
        const workTray = getWorkTrayNameValue(row);
        
        // Logic based on requirements
        if (dutAccess === "no") {
            return "NO ACCESS";
        } else if (dutAccess === "yes" && !workTray) {
            return "Require work tray name";
        } else if (workTray) {
            return workTray.toUpperCase();
        } else {
            return "NO ACCESS"; // Default fallback
        }
    }

    function generateRankVariations(rank) {
        const rankLower = rank.toString().trim().toLowerCase();
        const variations = [];
        
        // Constable variations
        if (rankLower.includes("constable") || rankLower === "cons") {
            variations.push("Constable");
            variations.push("Constable - PEQF");
            variations.push("Detective Constable");
            variations.push("New Constable");
            variations.push("New Detective Constable");
        }
        // Sergeant variations
        else if (rankLower.includes("sergeant") || rankLower === "sgt") {
            variations.push("Sergeant");
            variations.push("Detective Sergeant");
        }
        // Inspector variations
        else if (rankLower.includes("inspector") || rankLower === "insp") {
            variations.push("Inspector");
            variations.push("Detective Inspector");
        }
        
        return variations;
    }

    function getGradeMessage(grade, row) {
        const psopGrade = grade.toString().trim();
        
        // Check if grade contains "Unbanded" or "Band" followed by a space and a letter
        const unbandedPattern = /^Unbanded$/i;
        const bandPattern = /^Band\s+[A-Za-z]$/i;
        
        // Check if it's an officer rank (not Unbanded and not Band X)
        const isOfficerRank = !unbandedPattern.test(psopGrade) && !bandPattern.test(psopGrade);
        
        // Get column values
        const dutAccess = getDUTAccessColumnValue(row);
        const workTray = getWorkTrayNameValue(row);
        const securityRole = getSecurityRoleValue(row);
        
        // NEW: Check for officer rank with Access To Connect = No OR no Work Tray Name
        if (isOfficerRank && (dutAccess === "no" || !workTray)) {
            return "OFFICER ROLES HAVE ACCESS TO CONNECT";
        }
        
        // Check for staff role (Unbanded or Band X) with Access To Connect = Yes, has Work Tray Name, but no Security Role
        if ((unbandedPattern.test(psopGrade) || bandPattern.test(psopGrade)) && 
            dutAccess === "yes" && 
            workTray && 
            !securityRole) {
            return "STAFF REQUIRE A SECURITY ROLE";
        }
        
        // Original logic for non-band grades that don't meet above conditions
        if (isOfficerRank) {
            return "Officer role will have access";
        }
        
        return psopGrade;
    }

    function generateExcelData(rows) {
        const dutHeaders = ["Lookup type","Code","Meaning","Description","PSOP Grade","From","To","Enabled","Context Value","PSOP Organisation"];
        const dutData = [dutHeaders];

        const secHeaders = ["Lookup Type","Code","Meaning","Description","From","To","Enabled","Context Value","PSOP Organisation","PSOP Grade"];
        const secData = [secHeaders];

        let hasSecurity = false;

        rows.forEach((r,i) => {
            // Determine Work Tray Name based on new logic
            const workTray = determineWorkTrayName(r);
            
            // Get PSOP Grade with special handling (pass the row for additional checks)
            const rawGrade = (r["Rank/Band"] || "").toString();
            const psopGrade = getGradeMessage(rawGrade, r);
            
            // Get rank variations if applicable
            const rankVariations = generateRankVariations(rawGrade);
            
            // Trim highest org
            const psopOrg = getHighestNonEmptyLevel(r);

            // Get and validate security role
            const securityRoleRaw = getSecurityRoleValue(r);
            const securityRoleValidation = validateAndFormatSecurityRole(securityRoleRaw);

            // If we have rank variations, create multiple rows
            if (rankVariations.length > 0) {
                // Create DUT and Security rows for each rank variation
                rankVariations.forEach(variation => {
                    // DUT Mapping row for this variation
                    dutData.push([
                        "XXC_MPS_CONNECT_DEFAULTUNIT","", "", workTray, variation, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg
                    ]);

                    // Security Role row for this variation
                    if(securityRoleValidation.isValid){
                        hasSecurity = true;
                        secData.push([
                            "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, variation
                        ]);
                    } else if (securityRoleRaw) {
                        // Invalid security role - still add it but marked as invalid
                        hasSecurity = true;
                        secData.push([
                            "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, variation
                        ]);
                    }
                });
            } else {
                // Original single row logic
                // DUT Mapping row
                dutData.push([
                    "XXC_MPS_CONNECT_DEFAULTUNIT","", "", workTray, psopGrade, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg
                ]);

                // Security Role row
                if(securityRoleValidation.isValid){
                    hasSecurity = true;
                    secData.push([
                        "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, psopGrade
                    ]);
                } else if (securityRoleRaw) {
                    // Invalid security role - still add it but marked as invalid
                    hasSecurity = true;
                    secData.push([
                        "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, psopGrade
                    ]);
                }
            }
        });

        return { dutData, secData, hasSecurity };
    }

    function renderPreview(rows) {
        const { dutData, secData, hasSecurity } = generateExcelData(rows);
        
        // Function to determine cell background color
        function getCellBackgroundColor(cellValue, rowIndex, cellIndex, originalRow) {
            if (cellIndex === 3) { // Description column (index 3)
                const cellVal = cellValue.toString();
                const workTray = getWorkTrayNameValue(originalRow);
                const workTrayUpper = workTray.toUpperCase();
                
                // Check for OFFICER ROLES HAVE ACCESS TO CONNECT - RED
                if (cellVal === "OFFICER ROLES HAVE ACCESS TO CONNECT") {
                    return "#ffcccc"; // Red
                }
                
                // Check for STAFF REQUIRE A SECURITY ROLE - RED
                if (cellVal === "STAFF REQUIRE A SECURITY ROLE") {
                    return "#ffcccc"; // Red
                }
                
                // Check for INVALID SECURITY ROLE (in security preview) - RED
                if (cellIndex === 3 && cellVal === "INVALID SECURITY ROLE") {
                    return "#ffcccc"; // Red
                }
                
                // Check if work tray exists in Unit.csv - GREEN (only if no red conditions)
                if (workTray && cellVal !== "NO ACCESS" && cellVal !== "Require work tray name") {
                    // Check if work tray (capitalized) exists in validUnits
                    if (validUnits.size > 0 && validUnits.has(workTrayUpper)) {
                        return "#ccffcc"; // Green
                    } else if (validUnits.size > 0) {
                        return "#ffcccc"; // Red - not found in Unit.csv
                    }
                }
            }
            return ""; // Default no background
        }
        
        let html = `<h2>DUT Mapping Preview</h2><table><thead><tr>${dutData[0].map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>`;
        dutData.slice(1).forEach((row, rowIndex) => { 
            html += `<tr>`;
            row.forEach((cell, cellIndex) => {
                const bgColor = getCellBackgroundColor(cell, rowIndex, cellIndex, rows[rowIndex]);
                const style = bgColor ? `style="background-color: ${bgColor};"` : '';
                html += `<td ${style}>${cell}</td>`;
            });
            html += `</tr>`;
        });
        html += `</tbody></table>`;

        if(hasSecurity){
            html += `<h2>Security Roles Preview</h2><table><thead><tr>${secData[0].map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>`;
            secData.slice(1).forEach((row, rowIndex) => { 
                html += `<tr>`;
                row.forEach((cell, cellIndex) => {
                    const bgColor = getCellBackgroundColor(cell, rowIndex, cellIndex, rows[rowIndex]);
                    const style = bgColor ? `style="background-color: ${bgColor};"` : '';
                    html += `<td ${style}>${cell}</td>`;
                });
                html += `</tr>`;
            });
            html += `</tbody></table>`;
        }

        // Add validation summary
        const officerAccessIssues = [];
        const staffSecurityIssues = [];
        const validWorkTrays = [];
        const invalidWorkTrays = [];
        
        rows.forEach((r,i) => {
            const rawGrade = (r["Rank/Band"] || "").toString();
            const psopGrade = getGradeMessage(rawGrade, r);
            const dutAccess = getDUTAccessColumnValue(r);
            const workTray = getWorkTrayNameValue(r);
            const workTrayUpper = workTray.toUpperCase();
            
            // Check work tray against Unit.csv
            if (workTray && dutAccess === "yes") {
                if (validUnits.size > 0) {
                    if (validUnits.has(workTrayUpper)) {
                        validWorkTrays.push({
                            row: i + 2,
                            workTray: workTray,
                            match: "Valid unit found in Unit.csv"
                        });
                    } else {
                        invalidWorkTrays.push({
                            row: i + 2,
                            workTray: workTray,
                            match: "NOT FOUND in Unit.csv"
                        });
                    }
                }
            }
            
            // Check for officer access issues
            if (psopGrade === "OFFICER ROLES HAVE ACCESS TO CONNECT") {
                officerAccessIssues.push({
                    row: i + 2,
                    grade: rawGrade,
                    dutAccess: dutAccess,
                    workTray: workTray
                });
            }
            
            // Check for staff security issues
            if (psopGrade === "STAFF REQUIRE A SECURITY ROLE") {
                staffSecurityIssues.push({
                    row: i + 2,
                    grade: rawGrade,
                    dutAccess: dutAccess,
                    workTray: workTray
                });
            }
        });

        if (validWorkTrays.length > 0) {
            html += `<h2 style="color: green;">Valid Work Trays (Found in Unit.csv)</h2>`;
            html += `<p>The following work trays are valid units:</p>`;
            html += `<ul>`;
            validWorkTrays.forEach(item => {
                html += `<li>Row ${item.row}: "<strong>${item.workTray}</strong>" → ${item.match}</li>`;
            });
            html += `</ul>`;
        }

        if (invalidWorkTrays.length > 0) {
            html += `<h2 style="color: red;">Invalid Work Trays (NOT in Unit.csv)</h2>`;
            html += `<p>The following work trays were NOT found in Unit.csv:</p>`;
            html += `<ul>`;
            invalidWorkTrays.forEach(item => {
                html += `<li>Row ${item.row}: "<strong>${item.workTray}</strong>" → ${item.match}</li>`;
            });
            html += `</ul>`;
        }

        if (officerAccessIssues.length > 0) {
            html += `<h2 style="color: red;">Officer Access Issues</h2>`;
            html += `<p>The following officer ranks have Access To Connect = No OR no Work Tray Name:</p>`;
            html += `<ul>`;
            officerAccessIssues.forEach(item => {
                html += `<li>Row ${item.row}: Grade "<strong>${item.grade}</strong>" - Access To Connect: ${item.dutAccess}, Work Tray Name: ${item.workTray || '(empty)'}</li>`;
            });
            html += `</ul>`;
        }

        if (staffSecurityIssues.length > 0) {
            html += `<h2 style="color: red;">Staff Security Role Issues</h2>`;
            html += `<p>The following staff roles (Unbanded or Band X) require a security role:</p>`;
            html += `<ul>`;
            staffSecurityIssues.forEach(item => {
                html += `<li>Row ${item.row}: Grade "<strong>${item.grade}</strong>" - Has Access To Connect = Yes and Work Tray Name but no Security Role</li>`;
            });
            html += `</ul>`;
        }

        // Add note about Unit.csv
        if (validUnits.size === 0) {
            html += `<h3 style="color: orange;">Note: Unit.csv not loaded or empty</h3>`;
            html += `<p>Work tray validation against Unit.csv is not available. Make sure Unit.csv is in the same directory as this HTML file.</p>`;
        } else {
            html += `<h3>Work Tray Validation</h3>`;
            html += `<p>Work trays are checked against Unit.csv (${validUnits.size} units loaded). Green background indicates a valid unit found in Unit.csv.</p>`;
        }

        previewContainer.innerHTML = html;
    }

    processBtn.addEventListener("click", () => {
        if(!uploadedFile || uploadedRows.length===0){ alert("Please upload a file first."); return; }
        const { dutData, secData, hasSecurity } = generateExcelData(uploadedRows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(dutData), "DUT Mapping");
        if(hasSecurity){
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(secData), "Security Roles");
        }
        const timestamp = new Date().toISOString().slice(0,19).replace(/[:]/g,'-');
        XLSX.writeFile(wb, `PSOP_Connect_${timestamp}.xlsx`);
    });

});
</script>
</body>
</html>
