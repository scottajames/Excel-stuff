<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>PSOP Connect - Excel Transformer with Preview</title>
<script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
<style>
body{font-family:Calibri, sans-serif;background:#f5f5f5;margin:0;padding:20px;color:#222}
.container{max-width:1200px;margin:0 auto}
h1{font-size:22px;margin-bottom:20px}
.upload-area{border:2px dashed #217346;padding:40px;text-align:center;background:white;border-radius:6px;color:#217346;cursor:pointer;font-weight:bold;margin-bottom:20px}
.upload-area:hover{background:#e6f2e6}
button{padding:10px 14px;border:none;border-radius:4px;background:#217346;color:#fff;cursor:pointer;font-size:16px;margin-bottom:20px;display:none;}
button:hover{background:#1a5a2f}
table{border-collapse:collapse;margin-top:20px;width:100%;font-family:Calibri,sans-serif;font-size:14px;table-layout:fixed}
th,td{border:1px solid #999;padding:6px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;text-align:left}
th{background:#217346;color:#fff;font-weight:bold;text-align:center}
.preview-section{margin-top:30px}
</style>
</head>
<body>
<div class="container">
  <h1>MBS - DUT & Security Mapping tool</h1>

  <h3>Known errors and how to fix them.</h3>
  <p><b>Nothing happens when I drag and drop my file:</b> sometimes when you drag and drop it does not work. The best thing to do is reload the page and instead of drag and dropping click on the "Drag &amp; Drop or Click to Upload Excel file" and select the file from your folders instead.</p>
  <p><b>It has put the incorrect security mapping:</b> you are still required to look and audit the mappings yourself which is why a preview of what you're going to download is shown. If someone has filled in the sheet wrong in MBS, this tool cannot edit the data; it only shows and formats the data the Excel file has.</p>
  <p><b>It is missing parts or all of the mapping:</b> this tool cannot edit mappingâ€”only format it from the file that is downloaded from MBS. The issue probably isn't the tool but the person who filled in the MBS file.</p>
<h3 style=color:red;>This is just a tool for mapping; it does not give authority for security roles.</h3>
<div id="uploadArea" class="upload-area">
Drag & Drop or Click to Upload MBS Excel file
<input type="file" id="fileInput" accept=".xlsx" style="display:none" />
</div>

<button id="processBtn">Process & Download Excel</button>

<div id="previewContainer" class="preview-section"></div>

<script>
document.addEventListener("DOMContentLoaded", () => {

    const uploadArea = document.getElementById("uploadArea");
    const fileInput = document.getElementById("fileInput");
    const previewContainer = document.getElementById("previewContainer");
    const processBtn = document.getElementById("processBtn");
    let uploadedFile = null;
    let uploadedRows = [];

    // VALID SECURITY ROLES LIST - EDIT THESE AS NEEDED
    // These are the valid security roles for column V
    // You can edit this list with your actual security roles
    const VALID_SECURITY_ROLES = [
        "test",           // Example role 1
        "test2",          // Example role 2  
        "test3",          // Example role 3
        "admin",          // Example role 4
        "viewer",         // Example role 5
        "editor",         // Example role 6
        "approver",       // Example role 7
        "supervisor",     // Example role 8
        "manager",        // Example role 9
        "auditor"         // Example role 10
    ];
    
    // Helper function to normalize security roles for comparison
    function normalizeSecurityRole(role) {
        if (!role) return "";
        return role.toString().trim().toLowerCase().replace(/\s+/g, " ");
    }

    // Upload handlers
    uploadArea.addEventListener("click", () => fileInput.click());
    uploadArea.addEventListener("dragover", e => { e.preventDefault(); uploadArea.style.background="#e6f2e6"; });
    uploadArea.addEventListener("dragleave", () => { uploadArea.style.background="white"; });
    uploadArea.addEventListener("drop", e => { 
        e.preventDefault(); 
        uploadArea.style.background="white"; 
        if(e.dataTransfer.files && e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); 
    });
    fileInput.addEventListener("change", e => handleFile(e.target.files[0]));

    function handleFile(file) {
        uploadedFile = file;
        uploadArea.textContent = `File Loaded: ${file.name}`;
        const reader = new FileReader();
        reader.onload = e => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            uploadedRows = XLSX.utils.sheet_to_json(sheet, { defval:"" });
            renderPreview(uploadedRows);
            processBtn.style.display = "inline-block"; // show download button
        };
        reader.readAsArrayBuffer(uploadedFile);
    }

    function getHighestNonEmptyLevel(row) {
        const levels = ["Level 8 Sub-Team","Level 7 Team","Level 6 Function","Level 5 Portfolio","Level 4 Organisation"];
        for (let lvl of levels) {
            if (row[lvl] && row[lvl].toString().trim() !== "") return row[lvl].toString().trim();
        }
        return "";
    }

    function getDUTAccessColumnValue(row) {
        // Try to find column S by index or by common names
        const columnNames = Object.keys(row);
        
        // Look for common DUT access column names - column S
        const dutColumnCandidates = [
            "Connect DUT?", 
            "DUT Access", 
            "Access to DUT",
            "Access To Connect", // Added this based on your description
            "Column S",  // Fallback
            columnNames[18] // Assuming S is 19th column (0-indexed 18)
        ];
        
        for (const colName of dutColumnCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim().toLowerCase();
            }
        }
        
        return "";
    }

    function getWorkTrayNameValue(row) {
        // Try to find column U (Work Tray Name)
        const columnNames = Object.keys(row);
        
        // Look for Work Tray Name column - column U
        const workTrayCandidates = [
            "Work Tray Name",
            "Column U",  // Fallback
            columnNames[20] // Assuming U is 21st column (0-indexed 20)
        ];
        
        for (const colName of workTrayCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim();
            }
        }
        
        return "";
    }

    function getSecurityRoleValue(row) {
        // Try to find column V (Connect Security Role)
        const columnNames = Object.keys(row);
        
        // Look for Security Role column - column V
        const securityCandidates = [
            "Connect Security Role",
            "Column V",  // Fallback
            columnNames[21] // Assuming V is 22nd column (0-indexed 21)
        ];
        
        for (const colName of securityCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim();
            }
        }
        
        return "";
    }

    function validateAndFormatSecurityRole(role) {
        if (!role) return { isValid: false, formattedRole: "", message: "" };
        
        const normalizedRole = normalizeSecurityRole(role);
        const isValid = VALID_SECURITY_ROLES.some(validRole => 
            normalizeSecurityRole(validRole) === normalizedRole
        );
        
        if (!isValid) {
            return { 
                isValid: false, 
                formattedRole: "Not a valid security role", 
                message: "Not a valid security role" 
            };
        }
        
        // Format as uppercase with underscores for spaces
        const formattedRole = role.toUpperCase().replace(/\s+/g, "_");
        
        return { 
            isValid: true, 
            formattedRole: formattedRole, 
            message: formattedRole 
        };
    }

    function determineWorkTrayName(row) {
        const dutAccess = getDUTAccessColumnValue(row);
        const workTray = getWorkTrayNameValue(row);
        
        // Logic based on requirements
        if (dutAccess === "no") {
            return "NO ACCESS";
        } else if (dutAccess === "yes" && !workTray) {
            return "Require work tray name";
        } else if (workTray) {
            return workTray.toUpperCase();
        } else {
            return "NO ACCESS"; // Default fallback
        }
    }

    function generateRankVariations(rank) {
        const rankLower = rank.toString().trim().toLowerCase();
        const variations = [];
        
        // Constable variations
        if (rankLower.includes("constable") || rankLower === "cons") {
            variations.push("Constable");
            variations.push("Constable - PEQF");
            variations.push("Detective Constable");
            variations.push("New Constable");
            variations.push("New Detective Constable");
        }
        // Sergeant variations
        else if (rankLower.includes("sergeant") || rankLower === "sgt") {
            variations.push("Sergeant");
            variations.push("Detective Sergeant");
        }
        // Inspector variations
        else if (rankLower.includes("inspector") || rankLower === "insp") {
            variations.push("Inspector");
            variations.push("Detective Inspector");
        }
        
        return variations;
    }

    function getGradeMessage(grade, row) {
        const psopGrade = grade.toString().trim();
        
        // Check if grade contains "Band" followed by a space and a letter
        const bandPattern = /^Band\s+[A-Za-z]$/i;
        
        // Get column values
        const dutAccess = getDUTAccessColumnValue(row);
        const workTray = getWorkTrayNameValue(row);
        const securityRole = getSecurityRoleValue(row);
        
        // Check the new condition: Band + letter, Access To Connect = Yes, has Work Tray Name, but no Security Role
        if (bandPattern.test(psopGrade) && 
            dutAccess === "yes" && 
            workTray && 
            !securityRole) {
            return "Requires Security Role";
        }
        
        // Original logic for non-band grades
        if (psopGrade && !bandPattern.test(psopGrade)) {
            return "Officer role will have access";
        }
        
        return psopGrade;
    }

    function generateExcelData(rows) {
        const dutHeaders = ["Lookup type","Code","Meaning","Description","PSOP Grade","From","To","Enabled","Context Value","PSOP Organisation"];
        const dutData = [dutHeaders];

        const secHeaders = ["Lookup Type","Code","Meaning","Description","From","To","Enabled","Context Value","PSOP Organisation","PSOP Grade"];
        const secData = [secHeaders];

        let hasSecurity = false;

        rows.forEach((r,i) => {
            // Determine Work Tray Name based on new logic
            const workTray = determineWorkTrayName(r);
            
            // Get PSOP Grade with special handling (pass the row for additional checks)
            const rawGrade = (r["Rank/Band"] || "").toString();
            const psopGrade = getGradeMessage(rawGrade, r);
            
            // Get rank variations if applicable
            const rankVariations = generateRankVariations(rawGrade);
            
            // Trim highest org
            const psopOrg = getHighestNonEmptyLevel(r);

            // Get and validate security role
            const securityRoleRaw = getSecurityRoleValue(r);
            const securityRoleValidation = validateAndFormatSecurityRole(securityRoleRaw);

            // If we have rank variations, create multiple rows
            if (rankVariations.length > 0) {
                // Create DUT and Security rows for each rank variation
                rankVariations.forEach(variation => {
                    // DUT Mapping row for this variation
                    dutData.push([
                        "XXC_MPS_CONNECT_DEFAULTUNIT","", "", workTray, variation, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg
                    ]);

                    // Security Role row for this variation
                    if(securityRoleValidation.isValid){
                        hasSecurity = true;
                        secData.push([
                            "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, variation
                        ]);
                    } else if (securityRoleRaw) {
                        // Invalid security role - still add it but marked as invalid
                        hasSecurity = true;
                        secData.push([
                            "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, variation
                        ]);
                    }
                });
            } else {
                // Original single row logic
                // DUT Mapping row
                dutData.push([
                    "XXC_MPS_CONNECT_DEFAULTUNIT","", "", workTray, psopGrade, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg
                ]);

                // Security Role row
                if(securityRoleValidation.isValid){
                    hasSecurity = true;
                    secData.push([
                        "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, psopGrade
                    ]);
                } else if (securityRoleRaw) {
                    // Invalid security role - still add it but marked as invalid
                    hasSecurity = true;
                    secData.push([
                        "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, psopGrade
                    ]);
                }
            }
        });

        return { dutData, secData, hasSecurity };
    }

    function renderPreview(rows) {
        const { dutData, secData, hasSecurity } = generateExcelData(rows);
        let html = `<h2>DUT Mapping Preview</h2><table><thead><tr>${dutData[0].map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>`;
        dutData.slice(1).forEach(row => { html+=`<tr>${row.map(c=>`<td>${c}</td>`).join('')}</tr>`; });
        html += `</tbody></table>`;

        if(hasSecurity){
            html += `<h2>Security Roles Preview</h2><table><thead><tr>${secData[0].map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>`;
            secData.slice(1).forEach(row => { html+=`<tr>${row.map(c=>`<td>${c}</td>`).join('')}</tr>`; });
            html += `</tbody></table>`;
        }

        // Add validation summary
        const invalidRoles = [];
        rows.forEach((r,i) => {
            const securityRoleRaw = getSecurityRoleValue(r);
            if (securityRoleRaw) {
                const validation = validateAndFormatSecurityRole(securityRoleRaw);
                if (!validation.isValid) {
                    invalidRoles.push({
                        row: i + 2, // +2 because Excel rows start at 1 and header is row 1
                        role: securityRoleRaw,
                        message: validation.message
                    });
                }
            }
        });

        if (invalidRoles.length > 0) {
            html += `<h2 style="color: red;">Validation Warnings</h2>`;
            html += `<p>The following security roles are not valid. Please check them against the valid roles list:</p>`;
            html += `<ul>`;
            invalidRoles.forEach(item => {
                html += `<li>Row ${item.row}: "${item.role}" - ${item.message}</li>`;
            });
            html += `</ul>`;
            html += `<p><strong>Valid Security Roles:</strong> ${VALID_SECURITY_ROLES.join(', ')}</p>`;
        }

        previewContainer.innerHTML = html;
    }

    processBtn.addEventListener("click", () => {
        if(!uploadedFile || uploadedRows.length===0){ alert("Please upload a file first."); return; }
        const { dutData, secData, hasSecurity } = generateExcelData(uploadedRows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(dutData), "DUT Mapping");
        if(hasSecurity){
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(secData), "Security Roles");
        }
        const timestamp = new Date().toISOString().slice(0,19).replace(/[:]/g,'-');
        XLSX.writeFile(wb, `PSOP_Connect_${timestamp}.xlsx`);
    });

});
</script>
</body>
</html>
