<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>PSOP Connect - Excel Transformer with Preview</title>
<script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
<style>
body{font-family:Calibri, sans-serif;background:#f5f5f5;margin:0;padding:20px;color:#222}
.container{max-width:1200px;margin:0 auto}
h1{font-size:22px;margin-bottom:20px}
.upload-area{border:2px dashed #217346;padding:40px;text-align:center;background:white;border-radius:6px;color:#217346;cursor:pointer;font-weight:bold;margin-bottom:20px}
.upload-area:hover{background:#e6f2e6}
button{padding:10px 14px;border:none;border-radius:4px;background:#217346;color:#fff;cursor:pointer;font-size:16px;margin-bottom:20px;display:none;}
button:hover{background:#1a5a2f}
table{border-collapse:collapse;margin-top:20px;width:100%;font-family:Calibri,sans-serif;font-size:14px;table-layout:fixed}
th,td{border:1px solid #999;padding:6px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;text-align:left}
th{background:#217346;color:#fff;font-weight:bold;text-align:center}
.preview-section{margin-top:30px}
</style>
</head>
<body>
<div class="container">
  <h1>MBS - DUT & Security Mapping tool</h1>

  <h3>Known errors and how to fix them.</h3>
  <p><b>Nothing happens when I drag and drop my file:</b> sometimes when you drag and drop it does not work. The best thing to do is reload the page and instead of drag and dropping click on the "Drag &amp; Drop or Click to Upload Excel file" and select the file from your folders instead.</p>
  <p><b>It has put the incorrect security mapping:</b> you are still required to look and audit the mappings yourself which is why a preview of what you're going to download is shown. If someone has filled in the sheet wrong in MBS, this tool cannot edit the data; it only shows and formats the data the Excel file has.</p>
  <p><b>It is missing parts or all of the mapping:</b> this tool cannot edit mapping—only format it from the file that is downloaded from MBS. The issue probably isn't the tool but the person who filled in the MBS file.</p>
<h3 style=color:red;>This is just a tool for mapping; it does not give authority for security roles.</h3>
<div id="uploadArea" class="upload-area">
Drag & Drop or Click to Upload MBS Excel file
<input type="file" id="fileInput" accept=".xlsx" style="display:none" />
</div>

<button id="processBtn">Process & Download Excel</button>

<div id="previewContainer" class="preview-section"></div>

<script>
document.addEventListener("DOMContentLoaded", () => {

    const uploadArea = document.getElementById("uploadArea");
    const fileInput = document.getElementById("fileInput");
    const previewContainer = document.getElementById("previewContainer");
    const processBtn = document.getElementById("processBtn");
    let uploadedFile = null;
    let uploadedRows = [];

    // VALID SECURITY ROLES LIST
    // These are the valid security roles for column V
    const VALID_SECURITY_ROLES = [
	"BOLT_ON_1",
	"BOLT_ON_2",
	"BOLT_ON_3",
	"BOLT_ON_4",
	"BOLT_ON_5",
	"BOLT_ON_6",
	"BOLT_ON_7",
	"BOLT_ON_8",
	"CONSTABLE",
	"SGT",
	"INSP",
	"C_INSP",
	"SUPT",
	"C_SUPT",
	"COMMDR",
	"DEP_ASS_COMMIS",
	"SUPT",
	"ASS_COMMIS",
	"DEP_COMMIS",
	"COMMIS",
	"MSC_CONS",
	"MSC_SGT",
	"MSC_INSP",
	"MSC_CINSP",
	"MSC_ASS_CO",
	"MSC_CO",
	"SGT_CUST",
	"HCP",
	"HCP_FTAC",
	"CCC",
	"DDO",
	"PAO",
	"PCSO",
	"INVESTIGATOR",
	"SUP_INVESTIGATOR",
	"ANPR",
	"FCR",
	"FORENSICS",
	"INTEL",
	"INTEL_MANAGER",
	"INTEL_SIU",
	"INTEL_SOURCE",
	"INTEL_ENQUIRY_LOG",
	"PNCB",
	"PROPERTY",
	"PSD",
	"TDIU",
	"CMS",
	"DDM",
	"CMT",
	"CPA",
	"CASE_TRAFFIC",
	"CJOMS",
	"MET_INTERNAL",
	"VIEW_AND_SEARCH",
	"VIEW_ONLY",
	"MI",
	"MOPI",
	"FLAGS_C2S",
	"FLAGS_NDH",
	"FLAGS_NT",
	"FLAGS_VIEW_USERS",
	"SEALED_AUDIT",
	"NO_FIELD_SEC",
	"COVERT_ACCESS_FLAG",
	"FLAG_CLOSED_ACCESS",
	"FLAG_SECURE_ACCESS",
	"FLAG_TEAM",
	"SW_ALL_ACCESS",
	"PMP_ALL_ACCESS",
	"PMP_USER",
	"SYS_ADMIN",
	"SYSADMIN_FULL",
	"SYSADMIN_DQ1",
	"SYSADMIN_DQ2",
	"SYS_ADMIN_DQFULL",
	"FULL_SYS_ADMIN",
	"SYSADMIN_CST",
	"SYSADMIN_CST_FULL",
	"LOCKED_ADMIN",
	"SYSADMIN_NEC"
    ];
    
    // Create a normalized version of valid roles for comparison
    const NORMALIZED_VALID_ROLES = VALID_SECURITY_ROLES.map(role => 
        normalizeSecurityRole(role)
    );
    
    // Helper function to normalize security roles for comparison
    function normalizeSecurityRole(role) {
        if (!role) return "";
        return role.toString()
            .trim()
            .toLowerCase()
            .replace(/_/g, ' ')      // Convert underscores to spaces
            .replace(/\s+/g, ' ')    // Normalize multiple spaces to single space
            .replace(/[^a-z0-9\s]/g, '') // Remove special characters
            .trim();
    }
    
    // Helper function to find matching valid role from input
    function findMatchingValidRole(inputRole) {
        if (!inputRole) return null;
        
        const normalizedInput = normalizeSecurityRole(inputRole);
        
        // Try to find exact match in normalized list
        const exactMatchIndex = NORMALIZED_VALID_ROLES.indexOf(normalizedInput);
        if (exactMatchIndex !== -1) {
            return VALID_SECURITY_ROLES[exactMatchIndex]; // Return original format
        }
        
        // If no exact match, try partial matching
        for (let i = 0; i < VALID_SECURITY_ROLES.length; i++) {
            const normalizedValid = NORMALIZED_VALID_ROLES[i];
            // Check if input contains valid role or valid role contains input
            if (normalizedInput.includes(normalizedValid) || 
                normalizedValid.includes(normalizedInput)) {
                return VALID_SECURITY_ROLES[i];
            }
        }
        
        return null;
    }

    // Upload handlers
    uploadArea.addEventListener("click", () => fileInput.click());
    uploadArea.addEventListener("dragover", e => { e.preventDefault(); uploadArea.style.background="#e6f2e6"; });
    uploadArea.addEventListener("dragleave", () => { uploadArea.style.background="white"; });
    uploadArea.addEventListener("drop", e => { 
        e.preventDefault(); 
        uploadArea.style.background="white"; 
        if(e.dataTransfer.files && e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); 
    });
    fileInput.addEventListener("change", e => handleFile(e.target.files[0]));

    function handleFile(file) {
        uploadedFile = file;
        uploadArea.textContent = `File Loaded: ${file.name}`;
        const reader = new FileReader();
        reader.onload = e => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            uploadedRows = XLSX.utils.sheet_to_json(sheet, { defval:"" });
            renderPreview(uploadedRows);
            processBtn.style.display = "inline-block"; // show download button
        };
        reader.readAsArrayBuffer(uploadedFile);
    }

    function getHighestNonEmptyLevel(row) {
        const levels = ["Level 8 Sub-Team","Level 7 Team","Level 6 Function","Level 5 Portfolio","Level 4 Organisation"];
        for (let lvl of levels) {
            if (row[lvl] && row[lvl].toString().trim() !== "") return row[lvl].toString().trim();
        }
        return "";
    }

    function getDUTAccessColumnValue(row) {
        // Try to find column S by index or by common names
        const columnNames = Object.keys(row);
        
        // Look for common DUT access column names - column S
        const dutColumnCandidates = [
            "Connect DUT?", 
            "DUT Access", 
            "Access to DUT",
            "Access To Connect", // Added this based on your description
            "Column S",  // Fallback
            columnNames[18] // Assuming S is 19th column (0-indexed 18)
        ];
        
        for (const colName of dutColumnCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim().toLowerCase();
            }
        }
        
        return "";
    }

    function getWorkTrayNameValue(row) {
        // Try to find column U (Work Tray Name)
        const columnNames = Object.keys(row);
        
        // Look for Work Tray Name column - column U
        const workTrayCandidates = [
            "Work Tray Name",
            "Column U",  // Fallback
            columnNames[20] // Assuming U is 21st column (0-indexed 20)
        ];
        
        for (const colName of workTrayCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim();
            }
        }
        
        return "";
    }

    function getSecurityRoleValue(row) {
        // Try to find column V (Connect Security Role)
        const columnNames = Object.keys(row);
        
        // Look for Security Role column - column V
        const securityCandidates = [
            "Connect Security Role",
            "Column V",  // Fallback
            columnNames[21] // Assuming V is 22nd column (0-indexed 21)
        ];
        
        for (const colName of securityCandidates) {
            if (row.hasOwnProperty(colName) && row[colName] !== undefined) {
                return row[colName].toString().trim();
            }
        }
        
        return "";
    }

    function validateAndFormatSecurityRole(role) {
        if (!role) return { isValid: false, formattedRole: "", message: "", matchedRole: null };
        
        const matchedValidRole = findMatchingValidRole(role);
        
        if (!matchedValidRole) {
            return { 
                isValid: false, 
                formattedRole: "INVALID: " + role.toUpperCase(), 
                message: "Not a valid security role", 
                matchedRole: null 
            };
        }
        
        // Return the role in the standard format (uppercase with underscores)
        const formattedRole = matchedValidRole;
        
        return { 
            isValid: true, 
            formattedRole: formattedRole, 
            message: formattedRole,
            matchedRole: matchedValidRole
        };
    }

    function determineWorkTrayName(row) {
        const dutAccess = getDUTAccessColumnValue(row);
        const workTray = getWorkTrayNameValue(row);
        
        // Logic based on requirements
        if (dutAccess === "no") {
            return "NO ACCESS";
        } else if (dutAccess === "yes" && !workTray) {
            return "Require work tray name";
        } else if (workTray) {
            return workTray.toUpperCase();
        } else {
            return "NO ACCESS"; // Default fallback
        }
    }

    function generateRankVariations(rank) {
        const rankLower = rank.toString().trim().toLowerCase();
        const variations = [];
        
        // Constable variations
        if (rankLower.includes("constable") || rankLower === "cons") {
            variations.push("Constable");
            variations.push("Constable - PEQF");
            variations.push("Detective Constable");
            variations.push("New Constable");
            variations.push("New Detective Constable");
        }
        // Sergeant variations
        else if (rankLower.includes("sergeant") || rankLower === "sgt") {
            variations.push("Sergeant");
            variations.push("Detective Sergeant");
        }
        // Inspector variations
        else if (rankLower.includes("inspector") || rankLower === "insp") {
            variations.push("Inspector");
            variations.push("Detective Inspector");
        }
        
        return variations;
    }

    function getGradeMessage(grade, row) {
        const psopGrade = grade.toString().trim();
        
        // Check if grade contains "Band" followed by a space and a letter
        const bandPattern = /^Band\s+[A-Za-z]$/i;
        
        // Get column values
        const dutAccess = getDUTAccessColumnValue(row);
        const workTray = getWorkTrayNameValue(row);
        const securityRole = getSecurityRoleValue(row);
        
        // Check the new condition: Band + letter, Access To Connect = Yes, has Work Tray Name, but no Security Role
        if (bandPattern.test(psopGrade) && 
            dutAccess === "yes" && 
            workTray && 
            !securityRole) {
            return "Requires Security Role";
        }
        
        // Original logic for non-band grades
        if (psopGrade && !bandPattern.test(psopGrade)) {
            return "Officer role will have access";
        }
        
        return psopGrade;
    }

    function generateExcelData(rows) {
        const dutHeaders = ["Lookup type","Code","Meaning","Description","PSOP Grade","From","To","Enabled","Context Value","PSOP Organisation"];
        const dutData = [dutHeaders];

        const secHeaders = ["Lookup Type","Code","Meaning","Description","From","To","Enabled","Context Value","PSOP Organisation","PSOP Grade"];
        const secData = [secHeaders];

        let hasSecurity = false;

        rows.forEach((r,i) => {
            // Determine Work Tray Name based on new logic
            const workTray = determineWorkTrayName(r);
            
            // Get PSOP Grade with special handling (pass the row for additional checks)
            const rawGrade = (r["Rank/Band"] || "").toString();
            const psopGrade = getGradeMessage(rawGrade, r);
            
            // Get rank variations if applicable
            const rankVariations = generateRankVariations(rawGrade);
            
            // Trim highest org
            const psopOrg = getHighestNonEmptyLevel(r);

            // Get and validate security role
            const securityRoleRaw = getSecurityRoleValue(r);
            const securityRoleValidation = validateAndFormatSecurityRole(securityRoleRaw);

            // If we have rank variations, create multiple rows
            if (rankVariations.length > 0) {
                // Create DUT and Security rows for each rank variation
                rankVariations.forEach(variation => {
                    // DUT Mapping row for this variation
                    dutData.push([
                        "XXC_MPS_CONNECT_DEFAULTUNIT","", "", workTray, variation, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg
                    ]);

                    // Security Role row for this variation
                    if(securityRoleValidation.isValid){
                        hasSecurity = true;
                        secData.push([
                            "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, variation
                        ]);
                    } else if (securityRoleRaw) {
                        // Invalid security role - still add it but marked as invalid
                        hasSecurity = true;
                        secData.push([
                            "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, variation
                        ]);
                    }
                });
            } else {
                // Original single row logic
                // DUT Mapping row
                dutData.push([
                    "XXC_MPS_CONNECT_DEFAULTUNIT","", "", workTray, psopGrade, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg
                ]);

                // Security Role row
                if(securityRoleValidation.isValid){
                    hasSecurity = true;
                    secData.push([
                        "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, psopGrade
                    ]);
                } else if (securityRoleRaw) {
                    // Invalid security role - still add it but marked as invalid
                    hasSecurity = true;
                    secData.push([
                        "XXC_MPS_CONNECT_RANK_ORG","", "", securityRoleValidation.formattedRole, "", "", "Y", "XXC_CONNECT_ORG_AND_GRADE", psopOrg, psopGrade
                    ]);
                }
            }
        });

        return { dutData, secData, hasSecurity };
    }

    function renderPreview(rows) {
        const { dutData, secData, hasSecurity } = generateExcelData(rows);
        let html = `<h2>DUT Mapping Preview</h2><table><thead><tr>${dutData[0].map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>`;
        dutData.slice(1).forEach(row => { html+=`<tr>${row.map(c=>`<td>${c}</td>`).join('')}</tr>`; });
        html += `</tbody></table>`;

        if(hasSecurity){
            html += `<h2>Security Roles Preview</h2><table><thead><tr>${secData[0].map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>`;
            secData.slice(1).forEach(row => { html+=`<tr>${row.map(c=>`<td>${c}</td>`).join('')}</tr>`; });
            html += `</tbody></table>`;
        }

        // Add validation summary
        const invalidRoles = [];
        const matchedRoles = [];
        
        rows.forEach((r,i) => {
            const securityRoleRaw = getSecurityRoleValue(r);
            if (securityRoleRaw) {
                const validation = validateAndFormatSecurityRole(securityRoleRaw);
                if (!validation.isValid) {
                    invalidRoles.push({
                        row: i + 2, // +2 because Excel rows start at 1 and header is row 1
                        role: securityRoleRaw,
                        message: validation.message
                    });
                } else {
                    matchedRoles.push({
                        row: i + 2,
                        input: securityRoleRaw,
                        matched: validation.matchedRole
                    });
                }
            }
        });

        if (matchedRoles.length > 0) {
            html += `<h2 style="color: green;">Matched Security Roles</h2>`;
            html += `<p>The following security roles were successfully matched:</p>`;
            html += `<ul>`;
            matchedRoles.forEach(item => {
                html += `<li>Row ${item.row}: "${item.input}" → <strong>${item.matched}</strong></li>`;
            });
            html += `</ul>`;
        }

        if (invalidRoles.length > 0) {
            html += `<h2 style="color: red;">Validation Warnings</h2>`;
            html += `<p>The following security roles are not valid. Please check them against the valid roles list:</p>`;
            html += `<ul>`;
            invalidRoles.forEach(item => {
                html += `<li>Row ${item.row}: "${item.role}" - ${item.message}</li>`;
            });
            html += `</ul>`;
        }

        // Show valid roles for reference
        html += `<h3>Valid Security Roles (accepted in any case/spacing format):</h3>`;
        html += `<div style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background: #f9f9f9;">`;
        html += `<p>${VALID_SECURITY_ROLES.join(', ')}</p>`;
        html += `<p><em>Note: Inputs will be matched regardless of case (sys_admin = SYS_ADMIN = Sys Admin) and spacing (sys admin = sys_admin)</em></p>`;
        html += `</div>`;

        previewContainer.innerHTML = html;
    }

    processBtn.addEventListener("click", () => {
        if(!uploadedFile || uploadedRows.length===0){ alert("Please upload a file first."); return; }
        const { dutData, secData, hasSecurity } = generateExcelData(uploadedRows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(dutData), "DUT Mapping");
        if(hasSecurity){
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(secData), "Security Roles");
        }
        const timestamp = new Date().toISOString().slice(0,19).replace(/[:]/g,'-');
        XLSX.writeFile(wb, `PSOP_Connect_${timestamp}.xlsx`);
    });

});
</script>
</body>
</html>

